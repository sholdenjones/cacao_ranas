---
title: "ranas_draft_analysis"
author: "S. Holden Jones"
date: "2024-09-26"
output: html_document
---

Use this document for analyses and figures to be used in paper

load packages
```{r, include=FALSE}
library(labdsv)
library(tidyverse)
library(vegan)
library(iNEXT)
library(sjmisc)
library(RColorBrewer) # for assigning plot colors
library(DHARMa) # for assessing model fit
library(SuppDists) # needed for assessing additional dist fits
library(lme4)
library(ggpubr) # for arranging multi-panel figures
library(iNEXT)
```

load data
```{r, include=FALSE}
ranas <- read_csv("data/processed_data/ranas_processed.csv")
ranas <- as_tibble(ranas)

new <- read_csv("data/processed_data/new_processed.csv")
new <- as_tibble(new)

new_no_priach <- read_csv("data/processed_data/new_no_priach_processed.csv")
new_no_priach <- as_tibble(new_no_priach)

new_threatened <- read_csv("data/processed_data/new_threatened_processed.csv")
new_threatened <- as_tibble(new_threatened)

### REVIEW THIS SECTION ###
new_mat <- read_csv("data/processed_data/new_mat_processed.csv")
new_mat <- as.matrix(new_mat)

new_mat_test <- read_csv("data/processed_data/new_mat_test_processed.csv")
new_mat_test <- as.matrix(new_mat_test)
### REVIEW THIS SECTION ###

site_data <- read_csv("data/processed_data/site_data_processed.csv")
site_data <- as_tibble(site_data)

site_type <- read_csv("data/processed_data/site_type_processed.csv")
site_type <- as_tibble(site_type)

richness_by_site <- read_csv(
  "data/processed_data/richness_by_site_processed.csv")
richness_by_site <- as_tibble(richness_by_site)

richness_by_site_no_priach <- read_csv(
  "data/processed_data/richness_by_site_no_priach_processed.csv")
richness_by_site_no_priach <- as_tibble(richness_by_site_no_priach)

threatened_richness_by_site <- read_csv(
  "data/processed_data/threatened_richness_by_site_processed.csv")
threatened_richness_by_site <- as_tibble(threatened_richness_by_site)

abundance_by_site <- read_csv(
  "data/processed_data/abundance_by_site_processed.csv")
abundance_by_site <- as_tibble(abundance_by_site)

abundance_by_site_no_priach <- read_csv(
  "data/processed_data/abundance_by_site_no_priach_processed.csv")
abundance_by_site <- as_tibble(abundance_by_site_no_priach)

diversity_by_site <- read_csv(
  "data/processed_data/diversity_by_site_processed.csv")
diversity_by_site <- as_tibble(diversity_by_site)

diversity_by_site_no_priach <- read_csv(
  "data/processed_data/diversity_by_site_no_priach_processed.csv")
diversity_by_site_no_priach <- as_tibble(diversity_by_site_no_priach)

trans_richness_local <- read_csv(
  "data/processed_data/trans_richness_local_processed.csv")
trans_richness_local <- as_tibble(trans_richness_local)
```

define a consistent palet, labels, and theme to be used in figures
```{r, include=FALSE}
# palet for comparisons of all 4 site types
pal <- brewer.pal(4, "BrBG")

# set a theme for ggplots
my_theme <- function() {
  theme_minimal() + 
   theme(legend.position = "none",
        plot.background = element_rect("white"),
        panel.background = element_rect("white"),
        panel.grid = element_line("grey90"),
        axis.line = element_line("gray25"),
        axis.text = element_text(size = 12, color = "gray25"),
        axis.title = element_text(size = 14, color = "gray25"),
        legend.text = element_text(size = 12))
}
```


#1. Compare richness and Shannon diversity of CCN-51 and Nacional

##a. Richness
- Use two-sample t-test b/c not perfectly paired in landscape and dif number of sites
- If remove VC-N (weird site turned out to be N, not paired), then can run paired t-test
```{r}
# create species richness vector for each cacao type
rich_ccn <- richness_by_site %>%
  filter(Tipo == 'C') %>%
  pull(no_species)
  
rich_n <- richness_by_site %>%
  filter(Tipo == 'N') %>%
  pull(no_species)

# run two-sample t-test for species richness
t.test(rich_ccn, rich_n, paired = FALSE)
```

- Here run paired t-test w/out VC-N
```{r}
# drop VC-N from df, this site messes up pairing for t-test
pair_rich_by_site <- richness_by_site %>%
  filter(Sitio != 'VC-N') %>%
  arrange(Pair) # sort by Pair so vectors pulled align with pairs

# create species richness vector for each cacao type
pair_rich_ccn <- pair_rich_by_site %>%
  filter(Tipo == 'C') %>%
  pull(no_species)
  
pair_rich_n <- pair_rich_by_site %>%
  filter(Tipo == 'N') %>%
  pull(no_species)

t.test(pair_rich_ccn, pair_rich_n, paired = TRUE)
```

Boxplot figure for CCN vs. Nacional species richness
```{r}
# site labels for 2 site comparison
site_labels <-  c("Shade \n (n = 12)", "Sun \n (n = 11)")

# reorder factor levels
richness_by_site$Tipo <- factor(richness_by_site$Tipo,
                         c("N", "C", "V", "B"))

richness_by_site_cacao <- richness_by_site %>%
  filter(Tipo == "C" | Tipo == 'N')

# plot species richness across landuse types using palet, my_theme
plot_richness_by_site_cacao <- ggplot(richness_by_site_cacao, 
                                     aes(x = Tipo, y = no_species, fill = Tipo)) +
  geom_boxplot() +
  scale_fill_manual(values = pal) + # order needs to match factor levels above
  scale_x_discrete(labels = c(site_labels)) +
  my_theme() + 
  labs(x = "Cacao type",
       y = "Species richness")

plot_richness_by_site_cacao
#ggsave("output/plot_richness_by_site_cacao.png", width = 10, height = 10)
```


##b. Shannon diversity
Compare Shannon diversity of CCN and Nacional
- same process as above, can be done with paired or two-sample t-test

two-sample t-test
```{r}
# Two sample t-test for shannon diversity:

# create Shannon diversity vector for each cacao type
shannon_ccn <- diversity_by_site %>%
  filter(Tipo == 'C') %>%
  pull(Shannon_Index)
  
shannon_n <- diversity_by_site %>%
  filter(Tipo == 'N') %>%
  pull(Shannon_Index)

# run two-sample t-test for shannon diversity
t.test(shannon_ccn, shannon_n, paired = FALSE)
```

paired t-test
```{r}
# Paired t-test for Shannon diversity 

# drop VC-N from df, this site messes up pairing for t-test
pair_diversity_by_site <- diversity_by_site %>%
  filter(Sitio != 'VC-N') %>%
  arrange(Pair) # sort by Pair so vectors pulled align with pairs

# create Shannon diversity vector for each cacao type
pair_shannon_ccn <- pair_diversity_by_site %>%
  filter(Tipo == 'C') %>%
  pull(Shannon_Index)
  
pair_shannon_n <- pair_diversity_by_site %>%
  filter(Tipo == 'N') %>%
  pull(Shannon_Index)

t.test(pair_shannon_ccn, pair_shannon_n, paired = TRUE)
```

Boxplot figure for CCN vs. Nacional Shannon diversity
```{r}
# reorder factor levels
diversity_by_site$Tipo <- factor(diversity_by_site$Tipo,
                         c("N", "C", "V", "B"))

shannon_by_site_cacao <- diversity_by_site %>%
  filter(Tipo == "C" | Tipo == 'N')

# plot Shannon diversity across landuse types using palet, my_theme
plot_shannon_by_site_cacao <- ggplot(shannon_by_site_cacao, 
                                     aes(x = Tipo, y = Shannon_Index, fill = Tipo)) +
  geom_boxplot() +
  scale_fill_manual(values = pal) + # order needs to match factor levels above
  scale_x_discrete(labels = c(site_labels)) +
  my_theme() + 
  labs(x = "Cacao type",
       y = "Shannon diversity")

plot_shannon_by_site_cacao
#ggsave("output/plot_shannon_by_site_cacao.png", width = 10, height = 10)
```


#2.Compare richness and Shannon diversity of forest and abandoned plantations

##a. Richness
- Use two-sample t-test b/c not paired and dif number of sites
```{r}
# create species richness vector for each cacao type
rich_forest <- richness_by_site %>%
  filter(Tipo == 'B') %>%
  pull(no_species)
  
rich_abandon <- richness_by_site %>%
  filter(Tipo == 'V') %>%
  pull(no_species)

# run two-sample t-test for species richness
t.test(rich_forest, rich_abandon, paired = FALSE)
```

Boxplot figure for forest vs. abandoned species richness
```{r}
site_labels <- c("Abandoned \n (n = 4)", "Forest \n (n = 5)")

# reorder factor levels
richness_by_site$Tipo <- factor(richness_by_site$Tipo,
                         c("N", "C", "V", "B"))

richness_by_site_inactive <- richness_by_site %>%
  filter(Tipo == "B" | Tipo == 'V')

# plot species richness across landuse types using palet, my_theme
plot_richness_by_site_inactive <- ggplot(richness_by_site_inactive, 
                                     aes(x = Tipo, y = no_species, 
                                         fill = Tipo)) +
  geom_boxplot() +
  scale_fill_manual(values = c("#80CDC1", "#018571")) +
  scale_x_discrete(labels = c(site_labels)) +
  my_theme() + 
  labs(x = "Reference type",
       y = "Species richness")

plot_richness_by_site_inactive
#ggsave("output/plot_richness_by_site_inactive.png", width = 10, height = 10)
```

##b. Shannon diversity
Compare Shannon diversity of abandoned plantations and remnant forest

two-sample t-test
```{r}
# Two sample t-test for shannon diversity:

# create Shannon diversity vector for each type
shannon_abandon <- diversity_by_site %>%
  filter(Tipo == 'V') %>%
  pull(Shannon_Index)
  
shannon_forest <- diversity_by_site %>%
  filter(Tipo == 'B') %>%
  pull(Shannon_Index)

# run two-sample t-test for shannon diversity
t.test(shannon_abandon, shannon_forest, paired = FALSE)
```

Boxplot figure for abandoned vs. forest Shannon diversity
```{r}
# reorder factor levels
diversity_by_site$Tipo <- factor(diversity_by_site$Tipo,
                         c("N", "C", "V", "B"))

shannon_by_site_inactive <- diversity_by_site %>%
  filter(Tipo == "V" | Tipo == 'B')

# plot Shannon diversity across landuse types using palet, my_theme
plot_shannon_by_site_inactive <- ggplot(shannon_by_site_inactive, 
                                     aes(x = Tipo, y = Shannon_Index, 
                                         fill = Tipo)) +
  geom_boxplot() +
  scale_fill_manual(values = c("#80CDC1", "#018571")) +
  scale_x_discrete(labels = c(site_labels)) +
  my_theme() + 
  labs(x = "Reference type",
       y = "Shannon diversity")

plot_shannon_by_site_inactive
#ggsave("output/plot_shannon_by_site_inactive.png", width = 10, height = 10)
```


#3. Arrange figures for publication
arrange these four figures as panels in one window
```{r}
compare_rich_shannon <- ggarrange(
  plot_richness_by_site_cacao + rremove("xlab"), 
  plot_richness_by_site_inactive + rremove("xlab") + rremove("ylab"),
  plot_shannon_by_site_cacao,
  plot_shannon_by_site_inactive + rremove("ylab"),
  labels = c("A", "B", "C", "D"),
  ncol = 2, nrow = 2,
  label.x = 0.01, 
  label.y = 0.08 
)

compare_rich_shannon
#ggsave("output/compare_rich_shannon.png", width = 10, height = 10)
```


#4. Contextualize cacao sites against reference sites

To do this, need to use estimates of asymptotic species richness 
- b/c these sites did not have even sample coverage

# GOAL - use iNEXT to show what the sampling coverage is for each site
- then compare sampling coverage!
- then graphically display this?

```{r}
# library(iNEXT)
# 
# # Convert the flipped_df (where each column is a site) into a list of vectors
# site_list <- as.list(as.data.frame(t(new_mat_test[,-1])))  # Transpose and remove Final_ID column
# 
# # Names of each site (columns in the original data)
# names(site_list) <- colnames(new_mat_test)[-1]
# 
# # Calculate sampling coverage for each site using iNEXT
# # The first argument is the list of abundance vectors for each site
# iNEXT_out <- iNEXT(site_list, q = 0, datatype = "abundance")
# 
# # View the results
# iNEXT_out
# 
# # You can also visualize the sampling coverage curves
# library(ggplot2)
# ggiNEXT(iNEXT_out, type = 2)  # type=2 plots sampling coverage curve

```






Why is this so hard? Isn't this the whole point of the iNEXT package?
```{r}
# need to convert new_mat to a list I guess?
# new_mat_list <- apply(new_mat_test, 1, as.numeric)
# new_mat_list <- split(new_mat_list, seq(nrow(new_mat_test)))
# 
# out <- iNEXT(new_mat_list, q=c(0, 1, 2), datatype="abundance", endpoint=500)
# 
# #ggiNEXT(out, type=3)  # type=3 produces sample coverage-based rarefaction/extrapolation curves
# 
# # Define a custom shape palette (e.g., 32 different shapes, some repeating)
# shape_palette <- rep(1:6, length.out=32)  # Only 6 shapes available, so repeating them
# 
# # Plot using ggiNEXT with custom shapes
# ggiNEXT(out, type=3) +
#   scale_shape_manual(values = shape_palette)
# 
# 
# ## not sure how to interact with this data
# 
# # Check the structure of the iNEXT result
# str(out$iNextEst)
# 
# # Extract the sample coverage data
# coverage_data <- out$iNextEst %>% filter(method == "observed")
# 
# 
# # Convert your matrix to a list and assign site names
# site_names <- rownames(new_mat)  # Extract site names
# coverage_data$site <- site_names
# 
# library(ggplot2)
# 
# # Create a bar plot comparing sample coverage across sites
# ggplot(coverage_data, aes(x = site, y = SC, fill = site)) +
#   geom_bar(stat = "identity") +
#   theme(axis.text.x = element_text(angle = 90, hjust = 1)) +
#   labs(title = "Sample Coverage Across Sites", x = "Site", y = "Sample Coverage")
# 
# 
# 
# print(coverage_data)
```

code from Tamara
```{r}

# pull out specific columns, make a vectors

# con<-as.numeric(und$control[1:143])
# nuc<-as.numeric(und$nucleation[1:154])
# pla<-as.numeric(und$plantation[1:162])
# 
# und2<-list(con,nuc,pla)
# str(und2)
# names(und2) <- c("control", "nucleation", "plantation")
# str(und2)
# 
# out10 <- iNEXT(und2, q=0, datatype = "abundance",endpoint = 22000)
# 
# #plot sample-size-based curve
# ggiNEXT(out10, type=1,grey=TRUE)+
#   labs(y="Species richness", x="No. of individuals")+
#   labs(tag = "b)") +
#   theme(plot.tag.position = c(0.01, 1))
```





#5. Multivariate statistics for drivers of amphibian communities

Have a series of local (collected at quad-level),landscape (at 
site-level) variables - how do these explain the amphibian comm?

# a. PCA
- can only work for continuous variables!

https://jcoliver.github.io/learn-r/003-intro-multivariate.html
```{r}
pca_fit <- prcomp(x = trans_richness_local[, -c(1,3,6,14,15,16)], 
                  scale. = TRUE)

pca_summary <- summary(pca_fit)
pca_summary

ls(pca_summary) # Lists the objects produced by summary

pca_summary$importance

# biplot - kinda ugly!
biplot(x = pca_fit)

# just plot first two axes of PCA
plot(x = pca_fit$x[, 1],
     y = pca_fit$x[, 2],
     xlab = "PC 1",
     ylab = "PC 2")

# what if we included the plantation type for each transect here?
cacao_type <- unique(trans_richness_local$Tipo)

legend_cols <- c("#A6611A", "#DFC27D") 

# assign colors to legend
pt_cols <- rep(x = legend_cols[1], length = nrow(trans_richness_local))
pt_cols[cacao_type == cacao_type[2]] <- legend_cols[2]

# plot just first two axes, include coloring of points for each cacao type
plot(x = pca_fit$x[, 1],
     y = pca_fit$x[, 2],
     xlab = "PC 1",
     ylab = "PC 2",
     pch = 19,
     col = pt_cols)
legend("bottomleft", 
       legend = cacao_type, 
       pch = 19, 
       col = legend_cols, 
       cex = 0.8)
```


## NEED TO LOOK AT CORRELATION OF VARIABLES FIRST?
http://www.sthda.com/english/wiki/correlation-test-between-two-variables-in-r
```{r}
library(ggpubr)

# use mtcars to explore correlations
my_data <- mtcars
head(my_data, 6)

# visualize potential correlations
ggscatter(my_data, x = "mpg", y = "wt", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "Miles/(US) gallon", ylab = "Weight (1000 lbs)")

# Is the data normally distributed?

# Shapiro-Wilk normality test for mpg
shapiro.test(my_data$mpg) # => p = 0.1229
# Shapiro-Wilk normality test for wt
shapiro.test(my_data$wt) # => p = 0.09

# Visual inspection of the qqplots

# mpg
ggqqplot(my_data$mpg, ylab = "MPG")
# wt
ggqqplot(my_data$wt, ylab = "WT")

# Pearson correlation test
res <- cor.test(my_data$wt, my_data$mpg, 
                    method = "pearson")
res
# these variables are significantly correlated w/ correlation coefficient of -.87

### MY DATA ####

# Visualize potential correlations betwen two variables of interest

ggscatter(trans_richness_local, x = "tran_mean_veg", y = "tran_mean_hoja", 
          add = "reg.line", conf.int = TRUE, 
          cor.coef = TRUE, cor.method = "pearson",
          xlab = "tran_mean_veg", ylab = "tran_mean_hoja")

# Is the data normally distributed?

# Shapiro-Wilk normality test for tran_mean_veg
shapiro.test(trans_richness_local$tran_mean_veg) # => p < 2.2e-16 NOT NORMAL
# Shapiro-Wilk normality test for tran_mean_hoja
shapiro.test(trans_richness_local$tran_mean_hoja) # => p = 3.813e-11 NOT NORMAL

# Visual inspection of the qqplots

# tran_mean_veg
ggqqplot(trans_richness_local$tran_mean_veg, ylab = "tran_mean_veg")
# tran_mean_hoja
ggqqplot(trans_richness_local$tran_mean_hoja, ylab = "tran_mean_hoja")

#Note that, if the data are not normally distributed, it’s recommended to use the
# non-parametric correlation, including Spearman and Kendall rank-based correlation tests


# Pearson correlation test
res <- cor.test(trans_richness_local$tran_mean_veg, trans_richness_local$tran_mean_hoja, 
                    method = "pearson")
res

res
# these variables are significantly correlated w/ correlation coefficient of -.28

# THERE ARE OTHER WAYS TO CHECK FOR CORRELATION - KENDALL AND SPEARMAN
```





# b. glmer
- use glmer package b/c allows for inclusion of both random and rixed effects 

Okay, let's start with simpler models
- need site veg as random effects.
- start with just local variables?

# weird - ran with + (1|veg_bins) and got following error:
# boundary (singular) fit: see help('isSingular')

# ran with + veg_bins instead and got following error:
# Warning: Model failed to converge with max|grad| = 0.00276742 (tol = 0.002, component 1)

# consider using drop one tehcnique - drop one covariate from full model and see how reacts



## NEED TO REMOVE CORRELATED VARIABLES

## CORRELATION MATRIX _ VFA FROM STATS CLASS

```{r}
cor(trans_richness_local[, c("tran_mean_hoja_scaled", 
                             "tran_mean_CC_scaled", 
                             "water_dist_scaled", 
                             "forest_cover_400_scaled",
                             "tran_mean_veg_scaled")])

```

## VIF - NOT AN ISSUE HERE


```{r}
# Install the car package if it's not already installed
# install.packages("car")

# Load the car package
library(car)

# Fit the model
modfull <- glmer(num_species ~ tran_mean_hoja_scaled + 
                   tran_mean_CC_scaled + 
                   water_dist_scaled + 
                   forest_cover_400_scaled +
                   (1 | Sitio) + 
                   (1 | tran_mean_veg_scaled),
              data = trans_richness_local,
              family = poisson())

# Calculate VIF
vif(modfull)
```


## REMOVE VEG AS RANDOM EFFECT? SIMPLIFY RANDOM EFFECT STRUCTURE?
```{r}
# Fit the model
modfull <- glmer(num_species ~ tran_mean_hoja_scaled + 
                   tran_mean_CC_scaled + 
                   water_dist_scaled + 
                   forest_cover_400_scaled +
                   (1 | Sitio),
              data = trans_richness_local,
              family = poisson())

summary(modfull)


# Calculate VIF
vif(modfull)
```









# HERE WITH SCALED VARS
```{r}
# full model
modfull <- glmer(num_species ~ tran_mean_hoja_scaled + 
                   tran_mean_CC_scaled + 
                   water_dist_scaled + 
                   forest_cover_400_scaled +
                (1|Sitio) + 
                (1|tran_mean_veg_scaled),
              data = trans_richness_local,
              family = poisson())

# Warning: Model failed to converge with max|grad| = 0.00501921 (tol = 0.002, component 1)

summary(modfull)
```







```{r}
# full model - species by hoja, CC, forest_cover, water_dist
modfull <- glmer(num_species ~ hoja_bins + CC_bins + 
                   water_dist + forest_cover_400 +
              (1|Sitio) + (1|veg_bins),
              data = trans_richness_local,
              family = poisson())
# Warning: Some predictor variables are on very different scales: 
# consider rescaling boundary (singular) fit: see help('isSingular')
summary(modfull)


# mod1 - species by hoja, CC, sitio as random effect
mod1 <- glmer(num_species ~ hoja_bins + CC_bins +
              (1|Sitio),
              data = trans_richness_local,
              family = poisson())
summary(mod1)
# AIC 1158.2, BIC 1211.6
#None of the fixed effects (hoja_bins and CC_bins) have p-values less than 0.05, indicating that there are no statistically significant predictors in your current model. This suggests that the variation in num_species might not be explained well by these predictors.
coef(mod1)

# try model with just landscape variables
# first need to scale these two so on same scale
# trans_richness_local$forest_cover_400 <- scale(trans_richness_local$forest_cover_400)
# trans_richness_local$water_dist <- scale(trans_richness_local$water_dist)

mod2 <- glmer(num_species ~ forest_cover_400 + water_dist +
              (1|Sitio),
              data = trans_richness_local,
              family = poisson())
summary(mod2)
# AIC 1143.2, BIC 1159.6
# The intercept is significant, indicating a baseline number of species.Both predictor variables, forest_cover_400 and water_dist, do not appear to have a statistically significant impact on the number of species, as evidenced by their high p-values. This implies that variations in these predictors do not significantly change the expected count of species in this model.
coef(mod2)

# really just kinda trying different combinations now
mod3 <- glmer(num_species ~ forest_cover_400 + 
              (1|Sitio),
              data = trans_richness_local,
              family = poisson())
summary(mod3)
# AIC 1141.2

mod4 <- glmer(num_species ~ water_dist + 
              (1|Sitio),
              data = trans_richness_local,
              family = poisson())
summary(mod4)
# AIC 1141.7
```





```{r}
# # seems like throwing way too much into one model here!
# mod1 <- glmer(num_species ~ hoja_bins + CC_bins + forest_cover_400 + water_dist +
#                 (1|veg_bins) + (1|Sitio),
#               data = trans_richness_local,
#               family = poisson())
# #Warning: Some predictor variables are on very different scales: 
# # consider rescalingboundary (singular) fit: see help('isSingular')
# 
# mod2 <- glmer(num_species ~ hoja_bins + CC_bins + forest_cover_400 + water_dist +
#                (1|Sitio), 
#              data = trans_richness_local, 
#              family = poisson())
# #Warning: Some predictor variables are on very different scales: consider rescalingWarning: Model failed to converge with max|grad| = 0.0250694 (tol = 0.002, component 1)Warning: Model is nearly unidentifiable: very large eigenvalue
# # Rescale variables?;Model is nearly unidentifiable: large eigenvalue ratio
# # Rescale variables?
# 
# # can we rescale the continuous variables? try with CHATGPT
# trans_richness_local$forest_cover_400 <- scale(trans_richness_local$forest_cover_400)
# trans_richness_local$water_dist <- scale(trans_richness_local$water_dist)
# 
# # rerun previous model
# mod2 <- glmer(num_species ~ hoja_bins + CC_bins + forest_cover_400 + water_dist +
#                (1|Sitio), 
#              data = trans_richness_local, 
#              family = poisson())
# # Warning: Model failed to converge with max|grad| = 0.00258301 (tol = 0.002, component 1)
# 
# # woohoo! now try relaxing the tolerance threshold? no clue what any of this means
# mod2 <- glmer(num_species ~ hoja_bins + CC_bins + forest_cover_400 + water_dist + 
#               (1|Sitio), 
#               data = trans_richness_local, 
#               family = poisson(), 
#               control = glmerControl(optCtrl = list(maxfun = 100000), tolPwrss = 1e-4))
```






# from dancal!
```{r}
# # model germinants vs. site x planted
# m.bgerm <- glmer(Ngerm ~ SITE * x_or_c + (1|quad_dir2), family = poisson, data = seeds_crunchfinal2)
# overdisp_fun(m.bgerm) # sig. overdispersed based on chi-square test
# dispersion_glmer(m.bgerm)
# summary(m.bgerm)
# 
# # try negative binomial model
# m.bgerm2 <- glmer.nb(Ngerm ~ SITE * x_or_c + (1|quad_dir2), data = seeds_crunchfinal2) # fit a negative binomial test
# overdisp_fun(m.bgerm2) # still overdispersed, but a lot better...
# dispersion_glmer(m.bgerm2)
# summary(m.bgerm2)
# 
# # try including observation level random effect on poisson model
# m.bgerm3 <- glmer(Ngerm ~ SITE * x_or_c + (1|quad_dir2) + (1|OLRE), family = poisson, data = seeds_crunchfinal2)
# overdisp_fun(m.bgerm3) 
# dispersion_glmer(m.bgerm3)
# summary(m.bgerm3)
```




```{r}
# # https://www.rdocumentation.org/packages/lme4/versions/1.1-35.5/topics/glmer
# library(lattice)
# 
# xyplot(incidence/size ~ period|herd, cbpp, type=c('g','p','l'),
#        layout=c(3,5), index.cond = function(x,y)max(y))
# (gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
#               data = cbpp, family = binomial))
# 
# ## using nAGQ=0 only gets close to the optimum
# (gm1a <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
#                cbpp, binomial, nAGQ = 0))
# 
# ## using  nAGQ = 9  provides a better evaluation of the deviance
# ## Currently the internal calculations use the sum of deviance residuals,
# ## which is not directly comparable with the nAGQ=0 or nAGQ=1 result.
# ## 'verbose = 1' monitors iteratin a bit; (verbose = 2 does more):
# (gm1a <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
#                cbpp, binomial, verbose = 1, nAGQ = 9))
# 
# ## GLMM with individual-level variability (accounting for overdispersion)
# ## For this data set the model is the same as one allowing for a period:herd
# ## interaction, which the plot indicates could be needed.
# cbpp$obs <- 1:nrow(cbpp)
# (gm2 <- glmer(cbind(incidence, size - incidence) ~ period +
#     (1 | herd) +  (1|obs),
#               family = binomial, data = cbpp))
# 
# anova(gm1,gm2)
# 
# ## glmer and glm log-likelihoods are consistent
# gm1Devfun <- update(gm1,devFunOnly=TRUE)
# gm0 <- glm(cbind(incidence, size - incidence) ~ period,
#            family = binomial, data = cbpp)
# 
# ## evaluate GLMM deviance at RE variance=theta=0, beta=(GLM coeffs)
# gm1Dev0 <- gm1Devfun(c(0,coef(gm0)))
# 
# ## compare
# stopifnot(all.equal(gm1Dev0,c(-2*logLik(gm0))))
# ## the toenail oncholysis data from Backer et al 1998
# ## these data are notoriously difficult to fit
# if (FALSE) {
# if (require("HSAUR3")) {
#     gm2 <- glmer(outcome~treatment*visit+(1|patientID),
#                  data=toenail,
#                  family=binomial,nAGQ=20)
# }
# }
```




